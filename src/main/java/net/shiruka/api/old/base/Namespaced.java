package net.shiruka.api.old.base;

import com.google.common.base.Preconditions;
import java.util.Locale;
import java.util.UUID;
import java.util.regex.Pattern;
import net.shiruka.api.old.plugin.Plugin;
import org.jetbrains.annotations.NotNull;

/**
 * a class that represents a {@link String} based key which consists of two components which are a namespace and a key.
 */
public final class Namespaced {

  /**
   * the namespace representing all inbuilt keys.
   */
  private static final String MINECRAFT = "minecraft";

  /**
   * the namespace representing all keys generated by Shiru ka for backwards compatibility measures.
   */
  private static final String SHIRUKA = "shiruka";

  /**
   * the valid key pattern.
   */
  private static final Pattern VALID_KEY = Pattern.compile("[a-z0-9/._-]+");

  /**
   * the valid namespace pattern.
   */
  private static final Pattern VALID_NAMESPACE = Pattern.compile("[a-z0-9._-]+");

  /**
   * the key.
   */
  @NotNull
  private final String key;

  /**
   * the namespace.
   */
  @NotNull
  private final String namespace;

  /**
   * ctor.
   *
   * @param namespace the namespace.
   * @param key the key.
   */
  private Namespaced(@NotNull final String namespace, @NotNull final String key) {
    this.namespace = namespace.toLowerCase(Locale.ROOT);
    this.key = key.toLowerCase(Locale.ROOT);
  }

  /**
   * creates a new namespaced key instance.
   *
   * @param namespace the namespace to create.
   * @param key the key to create.
   *
   * @return a newly created namespaced key.
   */
  @NotNull
  public static Namespaced create(@NotNull final String namespace, @NotNull final String key) {
    final var finalNamespace = namespace.toLowerCase(Locale.ROOT);
    final var finalKey = key.toLowerCase(Locale.ROOT);
    Preconditions.checkArgument(Namespaced.VALID_NAMESPACE.matcher(finalNamespace).matches(),
      "Invalid namespace. Must be [a-z0-9._-]: %s", finalNamespace);
    Preconditions.checkArgument(Namespaced.VALID_KEY.matcher(finalKey).matches(), "" +
      "Invalid key. Must be [a-z0-9/._-]: %s", finalKey);
    final var string = String.format("%s : %s", finalNamespace, finalKey);
    Preconditions.checkArgument(string.length() < 256,
      "NamespacedKey must be less than 256 characters", string);
    return new Namespaced(finalNamespace, finalKey);
  }

  /**
   * creates a key in the Minecraft namespace.
   *
   * @param key the key to use.
   *
   * @return new key in the Minecraft namespace.
   */
  @NotNull
  public static Namespaced minecraft(@NotNull final String key) {
    return Namespaced.create(Namespaced.MINECRAFT, key);
  }

  /**
   * creates a key in the {@link Plugin#getName()} namespace.
   *
   * @param plugin the plugin to use.
   * @param key the key to use.
   *
   * @return new key in the plugin name namespace.
   */
  @NotNull
  public static Namespaced plugin(@NotNull final Plugin plugin, @NotNull final String key) {
    return Namespaced.create(plugin.getName(), key);
  }

  /**
   * creates a new random key in the {@link #SHIRUKA} namespace.
   *
   * @return new key.
   */
  @NotNull
  public static Namespaced randomKey() {
    return Namespaced.create(Namespaced.SHIRUKA, UUID.randomUUID().toString());
  }

  /**
   * the obtains the key.
   *
   * @return key.
   */
  @NotNull
  public String getKey() {
    return this.key;
  }

  /**
   * obtains the namespace.
   *
   * @return namespace.
   */
  @NotNull
  public String getNamespace() {
    return this.namespace;
  }

  @Override
  public int hashCode() {
    var hash = 5;
    hash = 47 * hash + this.namespace.hashCode();
    hash = 47 * hash + this.key.hashCode();
    return hash;
  }

  @Override
  public boolean equals(final Object obj) {
    if (obj == null) {
      return false;
    }
    if (this.getClass() != obj.getClass()) {
      return false;
    }
    final var other = (Namespaced) obj;
    return this.namespace.equals(other.namespace) && this.key.equals(other.key);
  }

  @Override
  public String toString() {
    return this.namespace + ":" + this.key;
  }
}
